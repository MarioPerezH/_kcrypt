/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.0.6.0 (NJsonSchema v10.0.23.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class CategoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:61692";
    }

    /**
     * @param request_idProceso (optional) 
     * @return OK
     */
    getProcessCategories(request_idProceso: number | null | undefined): Observable<GetProcessCategoriesResponse> {
        let url_ = this.baseUrl + "/api/Category/GetProcessCategories?";
        if (request_idProceso !== undefined)
            url_ += "request.idProceso=" + encodeURIComponent("" + request_idProceso) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessCategories(<any>response_);
                } catch (e) {
                    return <Observable<GetProcessCategoriesResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProcessCategoriesResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessCategories(response: HttpResponseBase): Observable<GetProcessCategoriesResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetProcessCategoriesResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProcessCategoriesResponse>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ClientServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:61692";
    }

    /**
     * @param request_idClienteDestino (optional) 
     * @return OK
     */
    getUsersClient(request_idClienteDestino: number | null | undefined): Observable<GetUsersClientResponse> {
        let url_ = this.baseUrl + "/api/Client/GetUsersClient?";
        if (request_idClienteDestino !== undefined)
            url_ += "request.idClienteDestino=" + encodeURIComponent("" + request_idClienteDestino) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersClient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersClient(<any>response_);
                } catch (e) {
                    return <Observable<GetUsersClientResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUsersClientResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsersClient(response: HttpResponseBase): Observable<GetUsersClientResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetUsersClientResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUsersClientResponse>(<any>null);
    }

    /**
     * @return OK
     */
    setNewAccount(request: SetNewAccountRequest): Observable<SetNewAccountResponse> {
        let url_ = this.baseUrl + "/api/Client/SetNewAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetNewAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetNewAccount(<any>response_);
                } catch (e) {
                    return <Observable<SetNewAccountResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SetNewAccountResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSetNewAccount(response: HttpResponseBase): Observable<SetNewAccountResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SetNewAccountResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SetNewAccountResponse>(<any>null);
    }

    /**
     * @param request_code (optional) 
     * @return OK
     */
    getValidationCodeActivationAccountRequest(request_code: string | null | undefined): Observable<GetValidationCodeActivationAccountRequestResponse> {
        let url_ = this.baseUrl + "/api/Client/GetValidationCodeActivationAccountRequest?";
        if (request_code !== undefined)
            url_ += "request.code=" + encodeURIComponent("" + request_code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetValidationCodeActivationAccountRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetValidationCodeActivationAccountRequest(<any>response_);
                } catch (e) {
                    return <Observable<GetValidationCodeActivationAccountRequestResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetValidationCodeActivationAccountRequestResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetValidationCodeActivationAccountRequest(response: HttpResponseBase): Observable<GetValidationCodeActivationAccountRequestResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetValidationCodeActivationAccountRequestResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetValidationCodeActivationAccountRequestResponse>(<any>null);
    }

    /**
     * @return OK
     */
    setActivationAccount(request: SetActivationAccountRequest): Observable<SetActivationAccountResponse> {
        let url_ = this.baseUrl + "/api/Client/SetActivationAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetActivationAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetActivationAccount(<any>response_);
                } catch (e) {
                    return <Observable<SetActivationAccountResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SetActivationAccountResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSetActivationAccount(response: HttpResponseBase): Observable<SetActivationAccountResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SetActivationAccountResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SetActivationAccountResponse>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class OperationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:61692";
    }

    /**
     * @param request_idOperacion (optional) 
     * @return OK
     */
    getOperation(request_idOperacion: number | null | undefined): Observable<GetOperationResponse> {
        let url_ = this.baseUrl + "/api/Operation/GetOperation?";
        if (request_idOperacion !== undefined)
            url_ += "request.idOperacion=" + encodeURIComponent("" + request_idOperacion) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOperation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOperation(<any>response_);
                } catch (e) {
                    return <Observable<GetOperationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetOperationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetOperation(response: HttpResponseBase): Observable<GetOperationResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetOperationResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetOperationResponse>(<any>null);
    }

    /**
     * @param request_idProceso (optional) 
     * @return OK
     */
    getOperations(request_idProceso: number | null | undefined): Observable<GetOperationsResponse> {
        let url_ = this.baseUrl + "/api/Operation/GetOperations?";
        if (request_idProceso !== undefined)
            url_ += "request.idProceso=" + encodeURIComponent("" + request_idProceso) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOperations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOperations(<any>response_);
                } catch (e) {
                    return <Observable<GetOperationsResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetOperationsResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetOperations(response: HttpResponseBase): Observable<GetOperationsResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetOperationsResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetOperationsResponse>(<any>null);
    }

    /**
     * @return OK
     */
    setOperation(request: SetOperationRequest): Observable<SetOperationResponse> {
        let url_ = this.baseUrl + "/api/Operation/SetOperation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetOperation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetOperation(<any>response_);
                } catch (e) {
                    return <Observable<SetOperationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SetOperationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSetOperation(response: HttpResponseBase): Observable<SetOperationResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SetOperationResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SetOperationResponse>(<any>null);
    }

    /**
     * @param request_idProceso (optional) 
     * @return OK
     */
    getProcessArtefactExternDefinition(request_idProceso: number | null | undefined): Observable<GetProcessArtefactExternDefinitionResponse> {
        let url_ = this.baseUrl + "/api/Operation/GetProcessArtefactExternDefinition?";
        if (request_idProceso !== undefined)
            url_ += "request.idProceso=" + encodeURIComponent("" + request_idProceso) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessArtefactExternDefinition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessArtefactExternDefinition(<any>response_);
                } catch (e) {
                    return <Observable<GetProcessArtefactExternDefinitionResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProcessArtefactExternDefinitionResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessArtefactExternDefinition(response: HttpResponseBase): Observable<GetProcessArtefactExternDefinitionResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetProcessArtefactExternDefinitionResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProcessArtefactExternDefinitionResponse>(<any>null);
    }

    /**
     * @param request_idOperation (optional) 
     * @return OK
     */
    getOperationArtefactExtern(request_idOperation: number | null | undefined): Observable<GetOperationArtefactExternResponse> {
        let url_ = this.baseUrl + "/api/Operation/GetOperationArtefactExtern?";
        if (request_idOperation !== undefined)
            url_ += "request.idOperation=" + encodeURIComponent("" + request_idOperation) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOperationArtefactExtern(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOperationArtefactExtern(<any>response_);
                } catch (e) {
                    return <Observable<GetOperationArtefactExternResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetOperationArtefactExternResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetOperationArtefactExtern(response: HttpResponseBase): Observable<GetOperationArtefactExternResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetOperationArtefactExternResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetOperationArtefactExternResponse>(<any>null);
    }

    /**
     * @return OK
     */
    uploadOperationArtefactExtern(): Observable<SetUploadFileOperationArtefactExternResponse> {
        let url_ = this.baseUrl + "/api/Operation/uploadOperationArtefactExtern";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadOperationArtefactExtern(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadOperationArtefactExtern(<any>response_);
                } catch (e) {
                    return <Observable<SetUploadFileOperationArtefactExternResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SetUploadFileOperationArtefactExternResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUploadOperationArtefactExtern(response: HttpResponseBase): Observable<SetUploadFileOperationArtefactExternResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SetUploadFileOperationArtefactExternResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SetUploadFileOperationArtefactExternResponse>(<any>null);
    }

    /**
     * @param request_idOperacionArtefacto (optional) 
     * @return OK
     */
    downloadOperationArtefactExtern(request_idOperacionArtefacto: number | null | undefined): Observable<GetDownloadFileOperationArtefactResponse> {
        let url_ = this.baseUrl + "/api/Operation/DownloadOperationArtefactExtern?";
        if (request_idOperacionArtefacto !== undefined)
            url_ += "request.idOperacionArtefacto=" + encodeURIComponent("" + request_idOperacionArtefacto) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadOperationArtefactExtern(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadOperationArtefactExtern(<any>response_);
                } catch (e) {
                    return <Observable<GetDownloadFileOperationArtefactResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDownloadFileOperationArtefactResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadOperationArtefactExtern(response: HttpResponseBase): Observable<GetDownloadFileOperationArtefactResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetDownloadFileOperationArtefactResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDownloadFileOperationArtefactResponse>(<any>null);
    }

    /**
     * @param request_idOperacion (optional) 
     * @return OK
     */
    getLogOperationArtefactExtern(request_idOperacion: number | null | undefined): Observable<GetLogOperationArtefactResponse> {
        let url_ = this.baseUrl + "/api/Operation/GetLogOperationArtefactExtern?";
        if (request_idOperacion !== undefined)
            url_ += "request.idOperacion=" + encodeURIComponent("" + request_idOperacion) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLogOperationArtefactExtern(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLogOperationArtefactExtern(<any>response_);
                } catch (e) {
                    return <Observable<GetLogOperationArtefactResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLogOperationArtefactResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetLogOperationArtefactExtern(response: HttpResponseBase): Observable<GetLogOperationArtefactResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetLogOperationArtefactResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLogOperationArtefactResponse>(<any>null);
    }

    /**
     * @param request_idProceso (optional) 
     * @return OK
     */
    getProcessArtefactTransformedDefinition(request_idProceso: number | null | undefined): Observable<GetProcessArtefactTransformedDefinitionResponse> {
        let url_ = this.baseUrl + "/api/Operation/GetProcessArtefactTransformedDefinition?";
        if (request_idProceso !== undefined)
            url_ += "request.idProceso=" + encodeURIComponent("" + request_idProceso) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessArtefactTransformedDefinition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessArtefactTransformedDefinition(<any>response_);
                } catch (e) {
                    return <Observable<GetProcessArtefactTransformedDefinitionResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProcessArtefactTransformedDefinitionResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetProcessArtefactTransformedDefinition(response: HttpResponseBase): Observable<GetProcessArtefactTransformedDefinitionResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetProcessArtefactTransformedDefinitionResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProcessArtefactTransformedDefinitionResponse>(<any>null);
    }

    /**
     * @param request_idOperation (optional) 
     * @return OK
     */
    getOperationArtefactTransformed(request_idOperation: number | null | undefined): Observable<GetOperationArtefactTransformedResponse> {
        let url_ = this.baseUrl + "/api/Operation/GetOperationArtefactTransformed?";
        if (request_idOperation !== undefined)
            url_ += "request.idOperation=" + encodeURIComponent("" + request_idOperation) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOperationArtefactTransformed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOperationArtefactTransformed(<any>response_);
                } catch (e) {
                    return <Observable<GetOperationArtefactTransformedResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetOperationArtefactTransformedResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetOperationArtefactTransformed(response: HttpResponseBase): Observable<GetOperationArtefactTransformedResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetOperationArtefactTransformedResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetOperationArtefactTransformedResponse>(<any>null);
    }

    /**
     * @return OK
     */
    uploadOperationArtefactTransformed(): Observable<SetUploadFileOperationArtefactTransformedResponse> {
        let url_ = this.baseUrl + "/api/Operation/uploadOperationArtefactTransformed";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadOperationArtefactTransformed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadOperationArtefactTransformed(<any>response_);
                } catch (e) {
                    return <Observable<SetUploadFileOperationArtefactTransformedResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SetUploadFileOperationArtefactTransformedResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUploadOperationArtefactTransformed(response: HttpResponseBase): Observable<SetUploadFileOperationArtefactTransformedResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SetUploadFileOperationArtefactTransformedResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SetUploadFileOperationArtefactTransformedResponse>(<any>null);
    }

    /**
     * @param request_idOperacionArtefacto (optional) 
     * @return OK
     */
    downloadOperationArtefactTransformed(request_idOperacionArtefacto: number | null | undefined): Observable<GetDownloadFileOperationArtefactResponse> {
        let url_ = this.baseUrl + "/api/Operation/DownloadOperationArtefactTransformed?";
        if (request_idOperacionArtefacto !== undefined)
            url_ += "request.idOperacionArtefacto=" + encodeURIComponent("" + request_idOperacionArtefacto) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadOperationArtefactTransformed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadOperationArtefactTransformed(<any>response_);
                } catch (e) {
                    return <Observable<GetDownloadFileOperationArtefactResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDownloadFileOperationArtefactResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadOperationArtefactTransformed(response: HttpResponseBase): Observable<GetDownloadFileOperationArtefactResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetDownloadFileOperationArtefactResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDownloadFileOperationArtefactResponse>(<any>null);
    }

    /**
     * @param request_idOperacion (optional) 
     * @return OK
     */
    getLogOperationArtefactTransformed(request_idOperacion: number | null | undefined): Observable<GetLogOperationArtefactResponse> {
        let url_ = this.baseUrl + "/api/Operation/GetLogOperationArtefactTransformed?";
        if (request_idOperacion !== undefined)
            url_ += "request.idOperacion=" + encodeURIComponent("" + request_idOperacion) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLogOperationArtefactTransformed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLogOperationArtefactTransformed(<any>response_);
                } catch (e) {
                    return <Observable<GetLogOperationArtefactResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLogOperationArtefactResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetLogOperationArtefactTransformed(response: HttpResponseBase): Observable<GetLogOperationArtefactResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetLogOperationArtefactResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLogOperationArtefactResponse>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:61692";
    }

    /**
     * @param request_idProceso (optional) 
     * @return OK
     */
    getReportsPBIX(request_idProceso: number | null | undefined): Observable<GetReportsPBIXResponse> {
        let url_ = this.baseUrl + "/api/Report/GetReportsPBIX?";
        if (request_idProceso !== undefined)
            url_ += "request.idProceso=" + encodeURIComponent("" + request_idProceso) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReportsPBIX(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReportsPBIX(<any>response_);
                } catch (e) {
                    return <Observable<GetReportsPBIXResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetReportsPBIXResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetReportsPBIX(response: HttpResponseBase): Observable<GetReportsPBIXResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetReportsPBIXResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetReportsPBIXResponse>(<any>null);
    }

    /**
     * @param request_idReportePBIX (optional) 
     * @return OK
     */
    getDownloadFilePBIX(request_idReportePBIX: number | null | undefined): Observable<GetDownloadFilePBIXResponse> {
        let url_ = this.baseUrl + "/api/Report/GetDownloadFilePBIX?";
        if (request_idReportePBIX !== undefined)
            url_ += "request.idReportePBIX=" + encodeURIComponent("" + request_idReportePBIX) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDownloadFilePBIX(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDownloadFilePBIX(<any>response_);
                } catch (e) {
                    return <Observable<GetDownloadFilePBIXResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDownloadFilePBIXResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetDownloadFilePBIX(response: HttpResponseBase): Observable<GetDownloadFilePBIXResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetDownloadFilePBIXResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDownloadFilePBIXResponse>(<any>null);
    }

    /**
     * @return OK
     */
    setStateReportsPBIX(request: SetStateReportsPBIXRequest): Observable<SetStateReportsPBIXResponse> {
        let url_ = this.baseUrl + "/api/Report/SetStateReportsPBIX";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetStateReportsPBIX(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetStateReportsPBIX(<any>response_);
                } catch (e) {
                    return <Observable<SetStateReportsPBIXResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SetStateReportsPBIXResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSetStateReportsPBIX(response: HttpResponseBase): Observable<SetStateReportsPBIXResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SetStateReportsPBIXResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SetStateReportsPBIXResponse>(<any>null);
    }

    /**
     * @return OK
     */
    deleteReportPBIX(request: DeleteReportsPBIXRequest): Observable<DeleteReportsPBIXResponse> {
        let url_ = this.baseUrl + "/api/Report/DeleteReportPBIX";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteReportPBIX(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteReportPBIX(<any>response_);
                } catch (e) {
                    return <Observable<DeleteReportsPBIXResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeleteReportsPBIXResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteReportPBIX(response: HttpResponseBase): Observable<DeleteReportsPBIXResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DeleteReportsPBIXResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeleteReportsPBIXResponse>(<any>null);
    }

    /**
     * @param request_idReporte (optional) 
     * @return OK
     */
    getUsersRolesReport(request_idReporte: number | null | undefined): Observable<GetUsersRolesReportResponse> {
        let url_ = this.baseUrl + "/api/Report/GetUsersRolesReport?";
        if (request_idReporte !== undefined)
            url_ += "request.idReporte=" + encodeURIComponent("" + request_idReporte) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersRolesReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersRolesReport(<any>response_);
                } catch (e) {
                    return <Observable<GetUsersRolesReportResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUsersRolesReportResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsersRolesReport(response: HttpResponseBase): Observable<GetUsersRolesReportResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetUsersRolesReportResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUsersRolesReportResponse>(<any>null);
    }

    /**
     * @param request_reportID (optional) 
     * @return OK
     */
    getDataModelRoleAssignments(request_reportID: string | null | undefined): Observable<GetDataModelRoleAssignmentsResponse> {
        let url_ = this.baseUrl + "/api/Report/GetDataModelRoleAssignments?";
        if (request_reportID !== undefined)
            url_ += "request.reportID=" + encodeURIComponent("" + request_reportID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDataModelRoleAssignments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDataModelRoleAssignments(<any>response_);
                } catch (e) {
                    return <Observable<GetDataModelRoleAssignmentsResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDataModelRoleAssignmentsResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetDataModelRoleAssignments(response: HttpResponseBase): Observable<GetDataModelRoleAssignmentsResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetDataModelRoleAssignmentsResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDataModelRoleAssignmentsResponse>(<any>null);
    }

    /**
     * @return OK
     */
    uploadReportPBIX(): Observable<SetUploadFileReportPBIXResponse> {
        let url_ = this.baseUrl + "/api/Report/uploadReportPBIX";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadReportPBIX(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadReportPBIX(<any>response_);
                } catch (e) {
                    return <Observable<SetUploadFileReportPBIXResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SetUploadFileReportPBIXResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUploadReportPBIX(response: HttpResponseBase): Observable<SetUploadFileReportPBIXResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SetUploadFileReportPBIXResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SetUploadFileReportPBIXResponse>(<any>null);
    }

    /**
     * @param request_reportID (optional) 
     * @return OK
     */
    getRolesReport(request_reportID: string | null | undefined): Observable<GetDataModelRolesReportResponse> {
        let url_ = this.baseUrl + "/api/Report/GetRolesReport?";
        if (request_reportID !== undefined)
            url_ += "request.reportID=" + encodeURIComponent("" + request_reportID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRolesReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRolesReport(<any>response_);
                } catch (e) {
                    return <Observable<GetDataModelRolesReportResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDataModelRolesReportResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetRolesReport(response: HttpResponseBase): Observable<GetDataModelRolesReportResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetDataModelRolesReportResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDataModelRolesReportResponse>(<any>null);
    }

    /**
     * @return OK
     */
    setRolesReport(request: SetPermissionsReportRequest): Observable<SetPermissionsReportResponse> {
        let url_ = this.baseUrl + "/api/Report/SetRolesReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetRolesReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetRolesReport(<any>response_);
                } catch (e) {
                    return <Observable<SetPermissionsReportResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SetPermissionsReportResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSetRolesReport(response: HttpResponseBase): Observable<SetPermissionsReportResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SetPermissionsReportResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SetPermissionsReportResponse>(<any>null);
    }

    /**
     * @param request_catalogItemID (optional) 
     * @return OK
     */
    getPoliciesCatalogItemFromXml(request_catalogItemID: string | null | undefined): Observable<GetPoliciesCatalogItemXmlResponse> {
        let url_ = this.baseUrl + "/api/Report/GetPoliciesCatalogItemFromXml?";
        if (request_catalogItemID !== undefined)
            url_ += "request.catalogItemID=" + encodeURIComponent("" + request_catalogItemID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPoliciesCatalogItemFromXml(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPoliciesCatalogItemFromXml(<any>response_);
                } catch (e) {
                    return <Observable<GetPoliciesCatalogItemXmlResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPoliciesCatalogItemXmlResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetPoliciesCatalogItemFromXml(response: HttpResponseBase): Observable<GetPoliciesCatalogItemXmlResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetPoliciesCatalogItemXmlResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPoliciesCatalogItemXmlResponse>(<any>null);
    }

    /**
     * @return OK
     */
    getReports(): Observable<GetReportsResponse> {
        let url_ = this.baseUrl + "/api/Report/GetReports";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReports(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReports(<any>response_);
                } catch (e) {
                    return <Observable<GetReportsResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetReportsResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetReports(response: HttpResponseBase): Observable<GetReportsResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GetReportsResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetReportsResponse>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class SecurityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:61692";
    }

    /**
     * @return OK
     */
    authenticationPBIRS(request: AuthenticationPBIRSRequest): Observable<any> {
        let url_ = this.baseUrl + "/api/Security/AuthenticationPBIRS";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticationPBIRS(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticationPBIRS(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticationPBIRS(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <any>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

export interface GetProcessCategoriesRequest {
    IdProceso?: number | undefined;
}

export interface GetProcessCategoriesResponse {
    Categorias?: CategoryFDto[] | undefined;
    Status?: boolean | undefined;
    Message?: string | undefined;
}

export interface CategoryFDto {
    IdProcesoCategoria?: number | undefined;
    Categoria?: string | undefined;
    Activo?: boolean | undefined;
}

export interface GetUsersClientRequest {
    IdClienteDestino?: number | undefined;
}

export interface GetUsersClientResponse {
    Usuarios?: UserFDto[] | undefined;
    Status?: boolean | undefined;
    Message?: string | undefined;
}

export interface UserFDto {
    IdUsuario?: number | undefined;
    IdCliente?: number | undefined;
    IdRol?: number | undefined;
    Nombre?: string | undefined;
    Apellido?: string | undefined;
    Email?: string | undefined;
    Activo?: boolean | undefined;
    IdEstadoCuenta?: number | undefined;
}

export interface SetNewAccountRequest {
    Usuario?: UserFDto | undefined;
}

export interface SetNewAccountResponse {
    Status?: boolean | undefined;
    Message?: string | undefined;
}

export interface GetValidationCodeActivationAccountRequest {
    Code?: string | undefined;
}

export interface GetValidationCodeActivationAccountRequestResponse {
    Status?: boolean | undefined;
    Message?: string | undefined;
}

export interface SetActivationAccountRequest {
    Code?: string | undefined;
}

export interface SetActivationAccountResponse {
    Status?: boolean | undefined;
    Message?: string | undefined;
}

export interface GetOperationRequest {
    IdOperacion?: number | undefined;
}

export interface GetOperationResponse {
    IdProceso?: number | undefined;
    IdOperacion?: number | undefined;
    IdOperacionEstado?: number | undefined;
    Nombre?: string | undefined;
    FechaCreacion?: string | undefined;
    FechaActualizacion?: string | undefined;
    IdUsuarioActualizado?: number | undefined;
    Activo?: boolean | undefined;
    Status?: boolean | undefined;
    Message?: string | undefined;
}

export interface GetOperationsRequest {
    IdProceso?: number | undefined;
}

export interface GetOperationsResponse {
    Archivos?: OperationFDto[] | undefined;
    Status?: boolean | undefined;
    Message?: string | undefined;
}

export interface OperationFDto {
    IdProceso?: number | undefined;
    IdOperacion?: number | undefined;
    IdOperacionEstado?: number | undefined;
    Proceso?: string | undefined;
    Operacion?: string | undefined;
    Autor?: string | undefined;
    FechaCreacion?: string | undefined;
    FechaActualizacion?: string | undefined;
    Activo?: boolean | undefined;
    Estado?: string | undefined;
    TotalArchivosExternos?: number | undefined;
}

export interface SetOperationRequest {
    IdProceso?: number | undefined;
    IdOperacion?: number | undefined;
    IdOperacionEstado?: number | undefined;
    Nombre?: string | undefined;
    Activo?: boolean | undefined;
}

export interface SetOperationResponse {
    IdOperacion?: number | undefined;
    Status?: boolean | undefined;
    Message?: string | undefined;
}

export interface GetProcessArtefactExternDefinitionRequest {
    IdProceso?: number | undefined;
}

export interface GetProcessArtefactExternDefinitionResponse {
    Artefactos?: ProcessArtefactExternDefinitionFDto[] | undefined;
    Status?: boolean | undefined;
    Message?: string | undefined;
}

export interface ProcessArtefactExternDefinitionFDto {
    IdProceso?: number | undefined;
    IdProcesoArtefactoExterno?: number | undefined;
    IdFormatoArchivo?: number | undefined;
    Artefacto?: string | undefined;
    Extension?: string | undefined;
    MimeType?: string | undefined;
}

export interface GetOperationArtefactExternRequest {
    IdOperation?: number | undefined;
}

export interface GetOperationArtefactExternResponse {
    Artefactos?: OperationArtefactExternFDto[] | undefined;
    Status?: boolean | undefined;
    Message?: string | undefined;
}

export interface OperationArtefactExternFDto {
    IdProceso?: number | undefined;
    IdProcesoArtefactoExterno?: number | undefined;
    IdOperacionArtefactoExterno?: number | undefined;
    Artefacto?: string | undefined;
    ArtefactoActivo?: boolean | undefined;
    NombreArchivo?: string | undefined;
    OperacionArtefactoExternoActivo?: boolean | undefined;
    IdFormatoArchivo?: number | undefined;
    Extension?: string | undefined;
    MimeType?: string | undefined;
}

export interface SetUploadFileOperationArtefactExternResponse {
    Status?: boolean | undefined;
    Message?: string | undefined;
}

export interface GetDownloadFileOperationArtefactRequest {
    IdOperacionArtefacto?: number | undefined;
}

export interface GetDownloadFileOperationArtefactResponse {
    Archivo?: FileFDto | undefined;
    Status?: boolean | undefined;
    Message?: string | undefined;
}

export interface FileFDto {
    NombreArchivo?: string | undefined;
    ContentType?: string | undefined;
    Extension?: string | undefined;
    Archivo?: string | undefined;
}

export interface GetLogOperationArtefactRequest {
    IdOperacion?: number | undefined;
}

export interface GetLogOperationArtefactResponse {
    Logs?: LogOperationArtefactFDto[] | undefined;
    Status?: boolean | undefined;
    Message?: string | undefined;
}

export interface LogOperationArtefactFDto {
    IdLog?: number | undefined;
    IdOperacionArtefacto?: number | undefined;
    IdLogTipo?: number | undefined;
    Descripcion?: string | undefined;
    TipoLog?: string | undefined;
    Artefacto?: string | undefined;
    NombreArchivo?: string | undefined;
    Version?: number | undefined;
}

export interface GetProcessArtefactTransformedDefinitionRequest {
    IdProceso?: number | undefined;
}

export interface GetProcessArtefactTransformedDefinitionResponse {
    Artefactos?: ProcessArtefactTransformedDefinitionFDto[] | undefined;
    Status?: boolean | undefined;
    Message?: string | undefined;
}

export interface ProcessArtefactTransformedDefinitionFDto {
    IdProceso?: number | undefined;
    IdProcesoArtefactoTransformado?: number | undefined;
    IdFormatoArchivo?: number | undefined;
    Artefacto?: string | undefined;
    Extension?: string | undefined;
    MimeType?: string | undefined;
}

export interface GetOperationArtefactTransformedRequest {
    IdOperation?: number | undefined;
}

export interface GetOperationArtefactTransformedResponse {
    Artefactos?: OperationArtefactTransformedFDto[] | undefined;
    Status?: boolean | undefined;
    Message?: string | undefined;
}

export interface OperationArtefactTransformedFDto {
    IdProceso?: number | undefined;
    IdProcesoArtefactoTransformado?: number | undefined;
    IdOperacionArtefactoTransformado?: number | undefined;
    Artefacto?: string | undefined;
    ArtefactoActivo?: boolean | undefined;
    NombreArchivo?: string | undefined;
    OperacionArtefactoTransformadoActivo?: boolean | undefined;
    IdFormatoArchivo?: number | undefined;
    Extension?: string | undefined;
    MimeType?: string | undefined;
}

export interface SetUploadFileOperationArtefactTransformedResponse {
    Status?: boolean | undefined;
    Message?: string | undefined;
}

export interface GetReportsPBIXRequest {
    IdProceso?: number | undefined;
}

export interface GetReportsPBIXResponse {
    Reportes?: ReportPBIXFDto[] | undefined;
    Status?: boolean | undefined;
    Message?: string | undefined;
}

export interface ReportPBIXFDto {
    IdProceso?: number | undefined;
    IdProcesoCategoria?: number | undefined;
    IdReportePBIX?: number | undefined;
    Categoria?: string | undefined;
    Descripcion?: string | undefined;
    NombreArchivo?: string | undefined;
    FechaCreacion?: string | undefined;
    FechaActualizacion?: string | undefined;
    Activo?: boolean | undefined;
    Ruta?: string | undefined;
    Guid?: string | undefined;
    TotalRoles?: number | undefined;
    TotalRolesAsignados?: number | undefined;
}

export interface GetDownloadFilePBIXRequest {
    IdReportePBIX?: number | undefined;
}

export interface GetDownloadFilePBIXResponse {
    Archivo?: FileFDto | undefined;
    Status?: boolean | undefined;
    Message?: string | undefined;
}

export interface SetStateReportsPBIXRequest {
    IdReporte?: number | undefined;
    Activo?: boolean | undefined;
}

export interface SetStateReportsPBIXResponse {
    Status?: boolean | undefined;
    Message?: string | undefined;
}

export interface DeleteReportsPBIXRequest {
    IdReporte?: number | undefined;
}

export interface DeleteReportsPBIXResponse {
    Status?: boolean | undefined;
    Message?: string | undefined;
}

export interface GetUsersRolesReportRequest {
    IdReporte?: number | undefined;
}

export interface GetUsersRolesReportResponse {
    Usuarios?: UserRolesReportFDto[] | undefined;
    Status?: boolean | undefined;
    Message?: string | undefined;
}

export interface UserRolesReportFDto {
    IdUsuario?: number | undefined;
    Nombre?: string | undefined;
    Apellido?: string | undefined;
    IdRoles?: string[] | undefined;
}

export interface GetDataModelRoleAssignmentsRequest {
    ReportID?: string | undefined;
}

export interface GetDataModelRoleAssignmentsResponse {
    Roles?: DataModelRoleAssignmentFDto[] | undefined;
    Status?: boolean | undefined;
    Message?: string | undefined;
}

export interface DataModelRoleAssignmentFDto {
    GroupUserName?: string | undefined;
    DataModelRoles?: string[] | undefined;
}

export interface SetUploadFileReportPBIXResponse {
    Status?: boolean | undefined;
    Message?: string | undefined;
}

export interface GetDataModelRolesReportRequest {
    ReportID?: string | undefined;
}

export interface GetDataModelRolesReportResponse {
    Roles?: DataModelRoleFDto[] | undefined;
    Status?: boolean | undefined;
    Message?: string | undefined;
}

export interface DataModelRoleFDto {
    ModelRoleId?: string | undefined;
    ModelRoleName?: string | undefined;
}

export interface SetPermissionsReportRequest {
    ReportID?: string | undefined;
    Roles?: DataModelRoleAssignmentFDto[] | undefined;
}

export interface SetPermissionsReportResponse {
    Status?: boolean | undefined;
    Message?: string | undefined;
}

export interface GetPoliciesCatalogItemRequest {
    CatalogItemID?: string | undefined;
}

export interface GetPoliciesCatalogItemXmlResponse {
    PoliticasXml?: any[] | undefined;
    Status?: boolean | undefined;
    Message?: string | undefined;
}

export interface GetReportsRequest {
}

export interface GetReportsResponse {
    Reportes?: ReportFDto[] | undefined;
    Status?: boolean | undefined;
    Message?: string | undefined;
}

export interface ReportFDto {
    Guid?: string | undefined;
    Nombre?: string | undefined;
    Ruta?: string | undefined;
    Categoria?: string | undefined;
    EsFavorito?: boolean | undefined;
    TotalRoles?: number | undefined;
    TotalRolesAsignados?: number | undefined;
}

export interface AuthenticationPBIRSRequest {
    Guid?: string | undefined;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}